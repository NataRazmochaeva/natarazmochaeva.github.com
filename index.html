<!doctype html>
<html lang="en">
<head>
	<title>Reflection (Three.js)</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link rel=stylesheet href="css/base.css"/>
</head>
<body>

<script src="js/Three.js"></script>
<script src="js/Detector.js"></script>
<script src="js/Stats.js"></script>
<script src="js/OrbitControls.js"></script>
<script src="js/THREEx.KeyboardState.js"></script>
<script src="js/THREEx.FullScreen.js"></script>
<script src="js/THREEx.WindowResize.js"></script>

<!-- jQuery code to display an information button and box when clicked. -->
<script src="js/jquery-1.9.1.js"></script>
<script src="js/jquery-ui.js"></script>
<link rel=stylesheet href="css/jquery-ui.css" />
<link rel=stylesheet href="css/info.css"/>
<div id="ThreeJS" style="position: absolute; left:0px; top:0px"></div>
<script>
/*
	Three.js "tutorials by example"
	Author: Lee Stemkoski
	Date: July 2013 (three.js v59dev)
*/

// MAIN

// standard global variables
var container, scene, camera, renderer, controls, stats;
var keyboard = new THREEx.KeyboardState();
var clock = new THREE.Clock();

// custom global variables
var mirrorSphere, mirrorSphereCamera; // for mirror material
var mirrorSphere1, mirrorSphereCamera1; // for mirror material

init();
animate();

// FUNCTIONS 		
function init() 
{
	var scene = new THREE.Scene();
		var camera = new THREE.PerspectiveCamera( 50, window.innerWidth/window.innerHeight, 0.1, 1000 );
		
		camera.position.x = -3.0;
		camera.position.y = 2.5;
		camera.position.z = 2.7;
		camera.lookAt(new THREE.Vector3(-0.2, -0.3, 0.2))

		var renderer = new THREE.WebGLRenderer();
		renderer.setClearColor(0xCCCCCC);
		renderer.setSize( window.innerWidth, window.innerHeight );
		//renderer.shadowMapEnabled = true;
		renderer.shadowMapSoft = true;
		renderer.shadowMapType = THREE.PCFSoftShadowMap;
		renderer.shadowMapBias = 0.0001;
		renderer.shadowMapDarkness = 2;
		renderer.shadowMapWidth = 4096;
		renderer.shadowMapHeight = 4096;
		document.body.appendChild( renderer.domElement );
		
		var light = new THREE.DirectionalLight(0xFFFFFF, 1);
		light.castShadow = true;
		light.position.set( 0, 3, 4);
		light.target.position.set( 0, 0.5, 0);		
		scene.add(light);
		
		var plight = new THREE.PointLight( 0xffffff, 0.4);
		plight.position.set( -5, 1, 0 );
		scene.add( plight );
		
		//var floorT = new THREE.TextureLoader('/images/floor.jpg');
	
		var planeGeometry = new THREE.PlaneGeometry(200,200);
		
		//var loader = new THREE.TextureLoader();
		//loader.needsUpdate = true;
		var texture = new THREE.ImageUtils.loadTexture('/images/checkerboard.png');
		var planeMaterial = new THREE.MeshLambertMaterial(
						{map: texture});			
		var plane = new THREE.Mesh(planeGeometry,planeMaterial);			
		scene.add(plane);
					
		plane.rotation.x = -Math.PI/2;
		plane.position.x = 0;
		plane.position.y = 0;
		plane.position.z = 0;
		plane.receiveShadow = true;
		//bot box
		var botCubeGeometry = new THREE.CubeGeometry(1.2,0.7,1.2);
		var botCubeMaterial = new THREE.MeshLambertMaterial({color: 0xff0000});
		var botCube = new THREE.Mesh(botCubeGeometry, botCubeMaterial);
		botCube.position.x = -1.7;
		botCube.position.y = 0;
		botCube.position.z = 1.5;
		botCube.castShadow = true;
		botCube.receiveShadow = true;
		scene.add(botCube);
		
		//top box
		var topCubeGeometry = new THREE.CubeGeometry(1.1,0.6,1.1);
		var topCubeMaterial = new THREE.MeshLambertMaterial(
					{color: 0x0FF000});
		var topCube = new THREE.Mesh(topCubeGeometry, topCubeMaterial);
		topCube.position.x = -0.15;
		topCube.position.y = 0.9;
		topCube.position.z = 0.15;
		topCube.castShadow = true;
		topCube.receiveShadow = true;
		scene.add(topCube);
		
		//HBOX						
		var hx = -0.1;
		var hy = 0;
		var hz = 1.9;
		for(i = 0; i < 11; i++){
			var HCubeGeometry = new THREE.CubeGeometry(1.7,0.02,0.02);
			var HCubeMaterial = new THREE.MeshLambertMaterial(
					{color: 0xFF0000});
			var HCube = new THREE.Mesh(HCubeGeometry, HCubeMaterial);
			HCube.position.x = hx;
			HCube.position.y = hy+i*0.17;
			HCube.position.z = hz;
			HCube.castShadow = true;
			HCube.receiveShadow = true;
			scene.add(HCube);
		}
		//VBOX
		for(i = 0; i < 11; i++){
			var VCubeGeometry = new THREE.CubeGeometry(0.02,1.7,0.02);
			var VCubeMaterial = new THREE.MeshLambertMaterial(
					{color: 0xFF0000});
			var VCube = new THREE.Mesh(VCubeGeometry, VCubeMaterial);
			VCube.position.x = hx-1.7/2+i*0.17;
			VCube.position.y = hy+1.7/2;
			VCube.position.z = hz;	
			VCube.castShadow = true;
			VCube.receiveShadow = true;
			scene.add(VCube);
		}
		
		//solidcyl
		var solCylGeometry = new THREE.CylinderGeometry(0.55,0.55,0.9,16,1);
		var solCylMaterial = new THREE.MeshLambertMaterial(
					{color: 0xFFFFFF});
		var solCyl = new THREE.Mesh(solCylGeometry, solCylMaterial);
		solCyl.position.x = -0.15;
		solCyl.position.y = 0.45;
		solCyl.position.z = 0.15;
		solCyl.castShadow = true;
		solCyl.receiveShadow = true;
		scene.add(solCyl);
		
		//largecellcyl
		var torGeometry = new THREE.TorusKnotGeometry(0.6,0.05,300,32,3,4);
		var torMaterial = new THREE.MeshPhongMaterial(
					{color: 0x00BB00});
		var torCyl = new THREE.Mesh(torGeometry, torMaterial);
		torCyl.position.x = -1.9;
		torCyl.position.y = 0.9;
		torCyl.position.z = -0.2;
		torCyl.castShadow = true;
		torCyl.receiveShadow = true;
		scene.add(torCyl);
		
		renderer.render(scene, camera);
}

function animate() 
{
    requestAnimationFrame( animate );
	render();		
	update();
}

function update()
{
	if ( keyboard.pressed("z") ) 
	{ 
		// do something
	}
	
	controls.update();
	stats.update();
}

function render() 
{
	// move the CubeCamera to the position of the object
	//    that has a reflective surface, "take a picture" in each direction
	//    and apply it to the surface.
	// need to hide surface before and after so that it does not
	//    "get in the way" of the camera
	mirrorSphere.visible = false;
	mirrorSphereCamera.updateCubeMap( renderer, scene );
	mirrorSphere.visible = true;

	mirrorSphere1.visible = false;
	mirrorSphereCamera1.updateCubeMap( renderer, scene );
	mirrorSphere1.visible = true;
	
	renderer.shadowMapEnabled = true;	
	renderer.render( scene, camera );
}

</script>

</body>
</html>
